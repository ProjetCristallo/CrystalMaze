<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: moveball.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: moveball.js</h1>

    


    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/** Manage the ball movement
 */
function moveBall() {

	//Imprecisions handling
	ball.body.x = Math.round(ball.body.x);
	ball.body.y = Math.round(ball.body.y);

	//Ball animation
	if(ball.isMoving &amp;&amp; ball.animations.paused){
		ball.animations.paused=false;
	}
	if(!ball.isMoving &amp;&amp; !ball.animations.paused){
		ball.animations.paused=true;
	}

	//Checks if the ball is moving
	if(ball.body.position.x === ball.body.prev.x &amp;&amp; 
			ball.body.position.y === ball.body.prev.y)
	{
		ball.isMoving = false;
	}
	else
	{
		ball.isMoving = true;
	}

	//the ball isn't moving and the game isn't paused : 
	//we check inputs from the user
	if(!ball.isMoving &amp;&amp; !(game.isPaused))
	{	
		if((controller.left.isDown || swipe==='left') &amp;&amp;
				checkMoveGroup('left'))
		{	
			lastDir = 'left';
			swipe = null;
			lastTurnBlocked = null;
			lastTurn = null;
			game.physics.arcade.overlap(ball,blockGroups.turn,
					setLastTurn);
			score++;
			ball.body.velocity.x = -constants.BALL.SPEED;
		}
		else if((controller.right.isDown || swipe==='right') &amp;&amp;
				checkMoveGroup('right'))
		{	
			lastDir = 'right';
			swipe = null;	
			lastTurnBlocked = null;
			lastTurn = null;
			game.physics.arcade.overlap(ball,blockGroups.turn,
					setLastTurn);
			score++;
			ball.body.velocity.x = +constants.BALL.SPEED;
		}
		else if((controller.up.isDown || swipe==='up')
				&amp;&amp; checkMoveGroup('up'))
		{	
			lastDir = 'up';
			swipe = null;	
			lastTurnBlocked = null;
			lastTurn = null;
			game.physics.arcade.overlap(ball,blockGroups.turn,
					setLastTurn);
			score++;
			ball.body.velocity.y = -constants.BALL.SPEED;
		}
		else if((controller.down.isDown || swipe==='down')
				&amp;&amp; checkMoveGroup('down'))
		{
			lastDir = 'down';
			swipe = null;	
			lastTurnBlocked = null;
			lastTurn = null;
			game.physics.arcade.overlap(ball,blockGroups.turn,
					setLastTurn);
			score++;
			ball.body.velocity.y = +constants.BALL.SPEED;
		}
	}
	else
	{
		//The ball is moving : we check the collisions/overlaps
		game.physics.arcade.collide(ball, blockGroups.simple, 
				normalBlockCollide,null, this);
		game.physics.arcade.collide(ball, blockGroups.breakable, 
				breakBlockCollide,null, this);
		game.physics.arcade.collide(ball, blockGroups.salt, 
				saltBlockCollide,null, this);
		game.physics.arcade.overlap(ball, blockGroups.porous, 
				porousBlockOverlap,null, this);
		game.physics.arcade.overlap(ball, blockGroups.end, 
				endLevel, null, this);
		game.physics.arcade.collide(ball, blockGroups.unilateral, 
				normalBlockCollide, null, this);
		game.physics.arcade.overlap(ball, blockGroups.hole, 
				holeOverlap, null, this);
		game.physics.arcade.overlap(ball, blockGroups.item, 
				itemCollide, null, this);
		game.physics.arcade.collide(ball, blockGroups.turn, 
				normalBlockCollide,null, this);
	}	
	// We check every time for the turn blocks to manage the case where the
	// ball is blocked right after a turn.
	checkTurn();
}

// variables used to control the comportment of the ball with the turn blocks.
var lastTurn;
var lastTurnBlocked;
/** Set lastTurn to turnBlock, useful to call with overlap on the group turn
 * @param {sprite} ball The moving ball from the world.
 * @param {sprite} turnBlock A block from the group turn that was the last to
 * block the ball.
 */
function setLastTurn(ball, turnBlock)
{
	lastTurn = turnBlock;
}

/** Check if the ball should be redirected by a turn block
 */
function checkTurn()
{
	for(var i=0; i&lt;blockGroups.turn.length;i++){
		current = blockGroups.turn.getAt(i);
		if(current.alive &amp;&amp; current != lastTurn &amp;&amp;
				game.physics.arcade.distanceBetween
				(current, ball) &lt; constants.
				TURN_SENSOR_PERCENTAGE*constants.TILE_SIZE)
		{
			lastTurn = current;
			turnBall(current);				
		}
	}	
}

/** Make the ball turn accordingly to turnBlock
 * @param {sprite} turnBlock A block tah should change the direction of ball
 */
function turnBall(turnBlock)
{
	//Definition of lastTurnedBlock
	if(ball.body.velocity.x > 0){
		lastTurnBlocked = 'right';
	}else if(ball.body.velocity.x &lt; 0){
		lastTurnBlocked = 'left';
	}else if(ball.body.velocity.y > 0){
		lastTurnBlocked ='down';
	}else if(ball.body.velocity.y &lt; 0){
		lastTurnBlocked = 'up';
	}

	//put ball and turnBlock at the same place to stay on a 
	//valid position
	ball.body.x = turnBlock.body.x;
	ball.body.y = turnBlock.body.y;


	//change the velocity of the ball accordingly to the type of turnBlock
	if(lastDir === 'left' || lastDir === 'right'){
		ball.body.velocity.x = 0;
		if(turnBlock.body.checkCollision.up === false){
			ball.body.velocity.y = -constants.BALL.SPEED;
			ball.body.y -= constants.TILE_SIZE/3;
			lastDir = 'up';
		}else{
			ball.body.velocity.y = constants.BALL.SPEED;
			ball.body.y += constants.TILE_SIZE/3;
			lastDir = 'down';
		}
	}else if(lastDir === 'up' || lastDir ==='down'){
		ball.body.velocity.y = 0; 
		if(turnBlock.body.checkCollision.left === false){
			ball.body.velocity.x = -constants.BALL.SPEED;
			ball.body.x -= constants.TILE_SIZE/3;
			lastDir = 'left';
		}else{
			ball.body.velocity.x = constants.BALL.SPEED;
			ball.body.x += constants.TILE_SIZE/3;
			lastDir = 'right';
		}
	}

	// we check for any overlap (i.e. incorrect move)
	if(game.physics.arcade.overlap(ball, blockGroups.unilateral, 
				checkUniTurn))
	{
		return;
	}
	else if(game.physics.arcade.overlap(ball, blockGroups.simple))
	{
		ball.body.velocity.x=0;
		ball.body.velocity.y=0;
		ball.body.x = turnBlock.body.x;
		ball.body.y = turnBlock.body.y;
		return;
	}
	else if(game.physics.arcade.overlap(ball, blockGroups.breakable, 
				breakBlockCollide))
	{
		ball.body.velocity.x=0;
		ball.body.velocity.y=0;
		ball.body.x = turnBlock.body.x;
		ball.body.y = turnBlock.body.y;
		return;
	}
	else 
	{
		var resetLastTurn = true;
		for(var i=0; i&lt;blockGroups.turn.length; i++){
			current = blockGroups.turn.getAt(i);
			if(current.alive &amp;&amp; current != turnBlock &amp;&amp; 
					game.physics.arcade.overlap(
						ball,current))
			{
				checkUniTurn(ball,current); 
				resetLastTurn =false;				
			}
		}
		if(resetLastTurn){
			lastTurnBlocked=null;
		}
	}
}

/** Manage the overlap due to a turn block redirecting the ball into a 
 * unilateral block.
 * @param {sprite} ball The ball redirected by a turn block.
 * @param {sprite} uniBlock A unilateral block overlapping the ball.
 */
function checkUniTurn(ball, uniBlock)
{
	if((uniBlock.body.checkCollision.up &amp;&amp; (ball.body.velocity.y > 0)) || 
			(uniBlock.body.checkCollision.down &amp;&amp; 
			 (ball.body.velocity.y &lt; 0)) || 
			(uniBlock.body.checkCollision.left &amp;&amp; 
			 (ball.body.velocity.x > 0)) || 
			(uniBlock.body.checkCollision.right &amp;&amp; 
			 (ball.body.velocity.x &lt; 0)))
	{
		//we put ball back on the turn case
		ball.body.x -= ball.body.velocity / constants.BALL.SPEED *
			constants.TILE_SIZE / 3;
		ball.body.y -= ball.body.velocity / constants.BALL.SPEED *
			constants.TILE_SIZE / 3;
		ball.body.velocity.x = 0;
		ball.body.velocity.y = 0;
	}else{
		lastTurnBlocked=null;
	}
}

/** Check if the asked move is correct in function of a precise block from turn.
 * @param {sprite} block The turn block to test. 
 * @param {string} dir The direction wanted (must be 'right', 'left', 'up' or 
 * 'down').
 */
function checkMoveTurn(block,dir)
{
	var authorized = checkMove(block, dir);
	if(block.y === ball.y &amp;&amp; block.x === ball.x) {
		if((dir==='up' &amp;&amp; block.body.checkCollision.up) || 
				(dir==='down' &amp;&amp; 
				 block.body.checkCollision.down) || 
				(dir==='left' &amp;&amp; 
				 block.body.checkCollision.left) || 
				(dir==='right' &amp;&amp; 
				 block.body.checkCollision.right))
		{
			authorized = false;	
		}
	}
	return authorized;
}


/** Check if the asked move is correct in function of any precise block (except
 * turn blocks).
 * @param {sprite} block The block to test. 
 * @param {string} dir The direction wanted (must be 'right', 'up', 'left' or 
 * 'down').
 * @param {boolean} booleanPorous Only needed if block is porous (in this case
 * booleanPorous must be set to true).
 */
function checkMove(block, dir, booleanPorous)
{
	var authorized = true;

	if(dir === lastTurnBlocked){
		authorized = false;
	}

	if(dir==='up' &amp;&amp; (block.y-ball.y===-constants.TILE_SIZE) &amp;&amp; 
			(block.x===ball.x) &amp;&amp; 
			(block.body.checkCollision.down || booleanPorous))
	{
		authorized = false;
	} else if(dir==='down' &amp;&amp; (block.y-ball.y===constants.TILE_SIZE) &amp;&amp; 
			(block.x===ball.x) &amp;&amp; 
			(block.body.checkCollision.up || booleanPorous))
	{
		authorized = false;
	} else if(dir==='left' &amp;&amp; (block.x-ball.x===-constants.TILE_SIZE) &amp;&amp; 
			(block.y===ball.y) &amp;&amp; 
			(block.body.checkCollision.right || booleanPorous))
	{
		authorized = false;
	} else if(dir==='right' &amp;&amp; ((block.x-ball.x)===constants.TILE_SIZE) &amp;&amp; 
			(block.y===ball.y) &amp;&amp; 
			(block.body.checkCollision.left || booleanPorous))
	{
		authorized = false;
	}
	return authorized;

}

/** Check that the movement asked is correct.
 * @param {string} dir The direction wanted (must be 'up', 'left', 'right' or 
 * 'down').
 */
function checkMoveGroup(dir)
{
	var current;
	var authorized = true;


	//We check with the game boundaries
	if((dir==='up' &amp;&amp; ball.y===0) || 
			(dir==='down' &amp;&amp; 
			 ball.y===constants.BACKGROUND_HEIGHT-ball.width) || 
			(dir==='right' &amp;&amp; 
			 ball.x===constants.BACKGROUND_WIDTH-ball.width) || 
			(dir==='left' &amp;&amp; ball.x===0)) {
				return false;
			}

	for(var i=0; i&lt;blockGroups.porous.length; i++){
		current = blockGroups.porous.getAt(i);
		if(current.alive &amp;&amp; ball.name === "ice") {
			authorized = authorized &amp;&amp; 
				checkMove(current, dir, true);
		}
	}

	for(i=0; i&lt;blockGroups.breakable.length;i++){
		current = blockGroups.breakable.getAt(i);
		if(current.alive) {
			authorized = authorized &amp;&amp; checkMove(current, dir);
		}
	}

	for(i=0; i&lt;blockGroups.salt.length;i++){
		current = blockGroups.salt.getAt(i);
		if(current.alive) {
			authorized = authorized &amp;&amp; checkMove(current, dir);
		}
	}

	for(i=0; i&lt;blockGroups.simple.length;i++){
		current = blockGroups.simple.getAt(i);
		if(current.alive) {
			authorized = authorized &amp;&amp; checkMove(current, dir);

		}
	}
	for(i=0; i&lt;blockGroups.unilateral.length; i++){
		current = blockGroups.unilateral.getAt(i);
		if(current.alive) {
			authorized = authorized &amp;&amp; checkMove(current, dir);
		}
	}
	for(i=0; i&lt;blockGroups.turn.length; i++){
		current = blockGroups.turn.getAt(i);
		if(current.alive){
			authorized = authorized &amp;&amp; checkMoveTurn(current, dir);
		}
	}
	return authorized;
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Global</h3><ul><li><a href="global.html#checkMove">checkMove</a></li><li><a href="global.html#checkMoveGroup">checkMoveGroup</a></li><li><a href="global.html#checkMoveTurn">checkMoveTurn</a></li><li><a href="global.html#checkTurn">checkTurn</a></li><li><a href="global.html#checkUniTurn">checkUniTurn</a></li><li><a href="global.html#moveBall">moveBall</a></li><li><a href="global.html#setLastTurn">setLastTurn</a></li><li><a href="global.html#turnBall">turnBall</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-alpha8</a> on Sat Jun 21 2014 10:41:22 GMT+0200 (CEST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
